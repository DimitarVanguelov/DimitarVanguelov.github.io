<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.217">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2023-02-27">

<title>backseat_programmer - Generating 1 Billion Fake People with Julia</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">backseat_programmer</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html" rel="" target="">
 <span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/DimitarVanguelov" rel="" target=""><i class="bi bi-github" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Generating 1 Billion Fake People with Julia</h1>
</div>



<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">February 27, 2023</p>
    </div>
  </div>
  
    
  </div>
  

</header>

<p>In a <a href="https://motherduck.com/blog/python-faker-duckdb-exploration/">recent MotherDuck blog post</a>, the author generated 1 billion fake people records using Python in order to analyze the data with DuckDB. I suspect the point of the article was to showcase how awesome <code>duckdb</code> is at handling large amounts of local data, but it did spend the majority of its time explaining the data generation process, which made for a fun read.</p>
<p>One of the more interesting tidbits from the article was:</p>
<blockquote class="blockquote">
<p>I used the GNU Parallel technique discussed above with a hefty m6i.32xlarge instance on Amazon EC2, though generated a billion people in 1k parquet files. This took about 2 hours to generate.</p>
</blockquote>
<p>Yikes, that’s a lot of firepower! <a href="https://instances.vantage.sh/aws/ec2/m6i.32xlarge">That machine</a> comes with 128 vCPUs and 512 GiB RAM, and costs about $6 an hour. So pretty hefty indeed.</p>
<p>Being a big fan of Julia, I decided to see what it would be like to generate such a dataset with Julia. More concretely, I wanted to see if I can use less resources (only my laptop) <em>and</em> have the process run in significantly less time. Not only that, I thought it be fun to explore the various modes of concurrency (multi-threading, multi-processing, async, etc) Julia offers.</p>
<p>The results were initially disappointing, as I’ll explain below, but in the end I did get that nice speed-up I was looking for.</p>
<section id="the-details" class="level2">
<h2 class="anchored" data-anchor-id="the-details">The Details</h2>
<p>The <a href="https://motherduck.com/blog/python-faker-duckdb-exploration/">original post</a> has the full details, but I’ll go over the basic details here. A <code>person</code> record consists of the following randomly generated fields:</p>
<pre><code>- id
- first_name
- last_name
- email
- company
- phone</code></pre>
<p>Using the Python <a href="https://faker.readthedocs.io/en/master/">Faker</a> library to generate the data and <a href="https://www.gnu.org/software/parallel/">GNU Parallel</a> to parallelize the operation, the author created 1,000 parquet files with 1 million records each before populating a <code>duckdb</code> database for further analysis.</p>
</section>
<section id="julia-first-attempt" class="level2">
<h2 class="anchored" data-anchor-id="julia-first-attempt">Julia: First Attempt</h2>
<p>Luckily, Julia has its own <a href="https://github.com/neomatrixcode/Faker.jl">Faker.jl</a> package. Using it is as simple as:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="im">using</span> <span class="bu">Faker</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>Faker.<span class="fu">first_name</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>"Wilfredo"</code></pre>
<p>Instead of putting all the fields in a dictionary, I created a struct instead:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Person</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    id<span class="op">::</span><span class="dt">String</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    first_name<span class="op">::</span><span class="dt">String</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    last_name<span class="op">::</span><span class="dt">String</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    email<span class="op">::</span><span class="dt">String</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    company<span class="op">::</span><span class="dt">String</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    phone<span class="op">::</span><span class="dt">String</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Aside from being a natural thing to do in Julia, this ended up being a really handy vehicle for populating a DataFrame, as we’ll see in a moment.</p>
<p>In order to construct the <code>Person</code> object, we have the following function, which is essentially the same as in the Python version in the original post:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">get_person</span>()</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    person <span class="op">=</span> <span class="fu">Person</span>(</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>        Faker.<span class="fu">random_int</span>(min<span class="op">=</span><span class="fl">1000</span>, max<span class="op">=</span><span class="fl">9999999999999</span>),</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>        Faker.<span class="fu">first_name</span>(),</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>        Faker.<span class="fu">last_name</span>(),</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>        Faker.<span class="fu">email</span>(),</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>        Faker.<span class="fu">company</span>(),</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>        Faker.<span class="fu">phone_number</span>()</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> person</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a><span class="fu">get_person</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>Person("8429894898777", "Christin", "Gleason", "Archie99@yahoo.com", "Mante, Hilll and Hessel", "1-548-869-5799 x26945")</code></pre>
<p>This approach clearly suffers from the same deficiency as the original in that the generated email address bears absolutely no semblance to the generated first and last names. But that’s ok, we’re just making up data for mocking and testing purposes anyhow.</p>
<p>To create an array of <code>Person</code>s, we can use a comprehension:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>list_of_five <span class="op">=</span> [<span class="fu">get_person</span>() for _ <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="fl">5</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>5-element Vector{Person}:
 Person("502327436522", "Simon", "Lind", "Franklyn.Satterfield@yahoo.com", "Rutherford-Barton", "054.718.0236")
 Person("1988647737198", "Charlott", "Jacobs", "Walter.Ziemann@hotmail.com", "Towne, Gorczany and Brekke", "839-605-0245 x477")
 Person("3335059941285", "Glory", "Brakus", "Nienow.Cassandra@lh.net", "Schuppe, Powlowski and Powlowski", "(122) 872-3081 x3643")
 Person("4996530776723", "Hedwig", "Pfannerstill", "wSchamberger@hg.net", "Langosh Group", "(594) 274-0196 x72486")
 Person("2217875886672", "Coletta", "Effertz", "Whitley.Bechtelar@mz.org", "Rippin Inc", "991.601.1323")</code></pre>
<p>Notice how we get a <code>Vector</code> of <code>Person</code>s… this is partially where that cool thing happens. Placing that vector in a <code>DataFrame</code> constructor creates a dataframe object for us without any hassle at all:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="im">using</span> <span class="bu">DataFrames</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> <span class="fu">DataFrame</span>(list_of_five)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>5×6 DataFrame
 Row │ id             first_name  last_name     email                           company                           phone                 
     │ String         String      String        String                          String                            String                
─────┼──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
   1 │ 502327436522   Simon       Lind          Franklyn.Satterfield@yahoo.com  Rutherford-Barton                 054.718.0236
   2 │ 1988647737198  Charlott    Jacobs        Walter.Ziemann@hotmail.com      Towne, Gorczany and Brekke        839-605-0245 x477
   3 │ 3335059941285  Glory       Brakus        Nienow.Cassandra@lh.net         Schuppe, Powlowski and Powlowski  (122) 872-3081 x3643
   4 │ 4996530776723  Hedwig      Pfannerstill  wSchamberger@hg.net             Langosh Group                     (594) 274-0196 x72486
   5 │ 2217875886672  Coletta     Effertz       Whitley.Bechtelar@mz.org        Rippin Inc                        991.601.1323</code></pre>
<p>That’s pretty neat!</p>
<p>Anyhow, with our basic functionality all set up, it’s time to do some light benchmarking to get a sense of how this code will perform. I started off small by generating only 10,000 records:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="im">using</span> <span class="bu">BenchmarkTools</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="pp">@btime</span> [<span class="fu">get_person</span>() for _ <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="fl">10_000</span>] <span class="op">|&gt;</span> DataFrame;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>6.531 s (5158878 allocations: 253.88 MiB)</code></pre>
<p>Oof, that result is not very comforting – taking 6.5 seconds just for 10,000 records does not bode well. Assuming linear scaling (which we probably can’t), it would take 6.5 * 100,000 seconds, or roughly 180 hours, to run the full thing.</p>
<p>At this point, I’m already thinking this whole idea is dead in the water, but was curious if a solution existed and decided not to give up yet and keep exploring options.</p>
<section id="multi-threading" class="level3">
<h3 class="anchored" data-anchor-id="multi-threading">Multi-threading</h3>
<p>The first tool in the arsenal to reach for in such a situation is probabably is multi-threading. <em>Actually</em>, the first tool to reach for is proper profiling, but when it comes to parallelizing code that is not ours, I would try multi-threading before exploring multi-processing or async.</p>
<p>Julia has a really handy macro <code>Threads.@threads</code> that you can stick in front of a <code>for</code> loop to parallelize it. But using <code>Base</code> Julia to handcraft the threaded population of a vector is <a href="https://discourse.julialang.org/t/thread-safe-array-building/3275/2">a bit clunky</a>, in my opinion, thus I opted for the excellent <a href="https://github.com/tkf/ThreadsX.jl">ThreadsX.jl</a> package, which makes this particular task a breeze. In essence, it parallelizes certain <code>Base</code> functions (such as <code>sum</code>, <code>reduce</code>, <code>map</code>, <code>collect</code>, etc.) and all one needs to do is simply put <code>ThreadsX.</code> in front of the function. In our case, it looks like this (with the benchmark result below):</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="im">using</span> <span class="bu">ThreadsX</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="pp">@btime</span> ThreadsX.<span class="fu">collect</span>(<span class="fu">get_person</span>() <span class="cf">for</span> _ <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="fl">100_000</span>) <span class="op">|&gt;</span> DataFrame;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>1.072 s (5140629 allocations: 258.32 MiB)</code></pre>
<p>Ok so that’s a little better, but running 12 threads and getting a 6x speed-up is not that great. More importantly, by our assumed linear scaling logic, the full 1 billion record run would still take approximately 30 hours on my laptop, just to generate the data, nevermind serializing it to disk.</p>
</section>
<section id="a-quick-benchmarking-aside" class="level3">
<h3 class="anchored" data-anchor-id="a-quick-benchmarking-aside">A quick benchmarking aside</h3>
<p>My laptop has 8 physical / 16 logical cores. For some reason I set the default number of threads to 12… I honestly don’t know why. Perhaps I was thinking “let’s leave some for the others” <code>¯\_(ツ)_/¯</code>.</p>
<p>Now it’s true that a lot of workloads won’t take advantage of all logical threads that are supposedly available, thus one is essentially bound to the number of physical cores, but some workloads might take advantage of those extra threads. So to be thorough, I ran the following benchmarks with 1 through 16 cores.</p>
<p>I saved my code to a file named <code>fake_naive.jl</code>:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="im">using</span> <span class="bu">BenchmarkTools</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="co"># --snip--</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(<span class="bu">Threads</span>.<span class="fu">nthreads</span>(), <span class="st">"</span><span class="sc">\t\t</span><span class="st">"</span>)</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="pp">@btime</span> ThreadsX.<span class="fu">collect</span>(<span class="fu">get_person</span>() <span class="cf">for</span> _ <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="fl">10_000</span>) <span class="op">|&gt;</span> DataFrame;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>and a short bash script as follows:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="co">#!/bin/bash</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="bu">printf</span> <span class="st">'Num Threads\tBenchmark Results\n'</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="va">$(</span><span class="fu">seq</span> 1 16<span class="va">)</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a><span class="cf">do</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># start a julia process with i threads</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>    <span class="ex">julia</span> <span class="at">-t</span> <span class="st">"</span><span class="va">$i</span><span class="st">"</span> <span class="at">-e</span> <span class="st">'include("fake_naive.jl")'</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a><span class="cf">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Running it gave the following results:</p>
<pre><code>Num Threads     Benchmark Results
1                 6.422 s (5146142 allocations: 256.55 MiB)
2                 3.361 s (5146774 allocations: 256.92 MiB)
3                 2.443 s (5141482 allocations: 257.37 MiB)
4                 1.990 s (5149584 allocations: 257.76 MiB)
5                 1.593 s (5138217 allocations: 257.54 MiB)
6                 1.448 s (5140074 allocations: 257.62 MiB)
7                 1.339 s (5141603 allocations: 257.70 MiB)
8                 1.296 s (5141621 allocations: 257.69 MiB)
9                 1.145 s (5139926 allocations: 258.29 MiB)
10                1.112 s (5137139 allocations: 258.15 MiB)
11                1.087 s (5146978 allocations: 258.64 MiB)
12                1.050 s (5142290 allocations: 258.40 MiB)
13                1.005 s (5137553 allocations: 258.16 MiB)
14                966.497 ms (5139312 allocations: 258.26 MiB)
15                955.672 ms (5147540 allocations: 258.66 MiB)
16                906.340 ms (5140219 allocations: 258.30 MiB)</code></pre>
<p>with the plotted version:</p>
<p><img src="./benchmark_plot_01.svg" class="img-fluid"></p>
<p>This is interesting. Clearly we see diminishing returns as we increase the number of threads past 8 or so, nevertheless there is a 30% speed improvement going from 8 threads to 16 threads, at least according to this benchmark.</p>
<p>Once again, assuming linear scaling, we can expect 16 threads to run in 0.90634 / 6.422 * 180 = 25.5 hours. Not nearly good enough!</p>
</section>
<section id="finishing-the-naive-code" class="level3">
<h3 class="anchored" data-anchor-id="finishing-the-naive-code">Finishing the naive code</h3>
<p>Despite knowing that my current approach is a losing battle, I wrote a function that generates the data <em>and</em> saves it to parquet files, in order to test out IO as well:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="im">using</span> <span class="bu">Parquet2</span>: writefile</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">save_the_people_sync</span>(num_people, num_files)</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span>num_files</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>        file_num <span class="op">=</span> <span class="fu">string</span>(i, pad<span class="op">=</span><span class="fu">ndigits</span>(num_files))</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>        file_loc <span class="op">=</span> <span class="st">"./data/outfile_</span><span class="sc">$</span>(file_num)<span class="st">.parquet"</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>        df <span class="op">=</span> ThreadsX.<span class="fu">collect</span>(<span class="fu">get_person</span>() <span class="cf">for</span> _ <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span>num_people) <span class="op">|&gt;</span> DataFrame</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>        <span class="fu">writefile</span>(file_loc, df; compression_codec<span class="op">=:</span>snappy)</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>along with a second async version:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">save_the_people_async</span>(num_people, num_files)</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>    <span class="pp">@sync</span> <span class="cf">for</span> i <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span>num_files</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>        file_num <span class="op">=</span> <span class="fu">string</span>(i, pad<span class="op">=</span><span class="fu">ndigits</span>(num_files))</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>        file_loc <span class="op">=</span> <span class="st">"./data/outfile_</span><span class="sc">$</span>(file_num)<span class="st">.parquet"</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>        df <span class="op">=</span> ThreadsX.<span class="fu">collect</span>(<span class="fu">get_person</span>() <span class="cf">for</span> _ <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span>num_people) <span class="op">|&gt;</span> DataFrame</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>        <span class="pp">@async</span> <span class="fu">writefile</span>(file_loc, df; compression_codec<span class="op">=:</span>snappy)</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The idea behind the <code>@async</code> code above is that while dataset<sub>n+1</sub> is being generated, dataset<sub>n</sub> is being written to disk. At least in theory.</p>
<p>Benchmarking the 10K records with 10 file writes (using 16 threads this time)</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="pp">@btime</span> <span class="fu">save_the_people_sync</span>(<span class="fl">10_000</span>, <span class="fl">10</span>);</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="pp">@btime</span> <span class="fu">save_the_people_async</span>(<span class="fl">10_000</span>, <span class="fl">10</span>);</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>gave the following results:</p>
<pre><code>  11.598 s (52145292 allocations: 2.57 GiB)
  11.018 s (52179590 allocations: 2.57 GiB)</code></pre>
<p>So the async stuff doesn’t really have much of an effect, at least for 10K records. Trying it out with 100K records results in:</p>
<pre><code>  109.919 s (521194490 allocations: 25.58 GiB)
  111.094 s (521135072 allocations: 25.58 GiB)</code></pre>
<p>Hmm… attempting to write bigger data asynchronously while using 16 threads to generate it actually resulted in a slight slowdown.</p>
<p>I tried one more thing, because I was maybe over-subscribing my CPU – I bumped my threads down to 12 again and got 124.67s for the non-async and 123.13s for the async version. Clearly the async wasn’t helping much. Though we did get some confirmation that, for this use case, it makes sense to max out the number of available threads, seeing as how lowering the thread-count did result in a ~12 second slowdown.</p>
<p>In any case, it was time to move on.</p>
</section>
</section>
<section id="diving-into-fakers-internals" class="level2">
<h2 class="anchored" data-anchor-id="diving-into-fakers-internals">Diving into Faker’s Internals</h2>
<p>Clearly doing a, more or less, 1-1 translation to Julia was not working. I posted my initial findings on the Julia Slack, and one user’s response inspired my next step:</p>
<blockquote class="blockquote">
<p>… I guess that the runtime is dominated by Faker, is it optimized for massive fake generation at all?</p>
</blockquote>
<p>I started looking into Faker.jl’s internals and noticed a couple of things: it was not exactly idiomatic Julia and the API did not explicitly support passing in an argument for number of records generated (at least that I could observe). In other words, you have to call code like this:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>last_name <span class="op">=</span> Faker.<span class="fu">last_name</span>()</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>email     <span class="op">=</span> Faker.<span class="fu">email</span>()</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>company   <span class="op">=</span> Faker.<span class="fu">company</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>and not like this:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>N <span class="op">=</span> <span class="fl">1_000_000</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>last_names <span class="op">=</span> Faker.<span class="fu">last_name</span>(N)</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>emails     <span class="op">=</span> Faker.<span class="fu">email</span>(N)</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>companies  <span class="op">=</span> Faker.<span class="fu">company</span>(N)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Meaning with each function call, you can only produce one record at a time. If you wanted to generate 1 million records, you would have to do 1 million function calls. And the way you’d do that is with a loop or comprehension, as I did above. But these million function calls might be more expensive than necessary.</p>
<p>The first thing I noticed about Faker.jl is that the data that it samples from, such as actual first and last names, is stored as text in YAML files, which makes sense. And for items such as email addresses and phone numbers, it stores a kind of pattern which then gets translated by Julia functions into (randomly generated) text.</p>
<p>For instance, the <code>name.yml</code> file contains this:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode yaml code-with-copy"><code class="sourceCode yaml"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="fu">en</span><span class="kw">:</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">faker</span><span class="kw">:</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">name</span><span class="kw">:</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">male_first_name</span><span class="kw">:</span><span class="at"> </span><span class="kw">[</span><span class="at">Aaron</span><span class="kw">,</span><span class="at"> Abdul</span><span class="kw">,</span><span class="at"> Abe</span><span class="kw">,</span><span class="at"> Abel</span><span class="kw">,</span><span class="at"> Abraham...</span><span class="kw">]</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">female_first_name</span><span class="kw">:</span><span class="at"> </span><span class="kw">[</span><span class="at">Abbey</span><span class="kw">,</span><span class="at"> Abbie</span><span class="kw">,</span><span class="at"> Abby</span><span class="kw">,</span><span class="at"> Abigail</span><span class="kw">,</span><span class="at"> Ada...</span><span class="kw">]</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">first_name</span><span class="kw">:</span></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a><span class="at">        </span><span class="kw">-</span><span class="at"> </span><span class="st">"#{female_first_name}"</span></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a><span class="at">        </span><span class="kw">-</span><span class="at"> </span><span class="st">"#{male_first_name}"</span></span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">last_name</span><span class="kw">:</span><span class="at"> </span><span class="kw">[</span><span class="at">Abbott</span><span class="kw">,</span><span class="at"> Abernathy</span><span class="kw">,</span><span class="at"> Abshire</span><span class="kw">,</span><span class="at"> Adams...</span><span class="kw">]</span></span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a><span class="at">      ...</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The function definitions for first names are:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="fu">male_first_name</span>()<span class="op">::</span><span class="dt">String </span><span class="op">=</span> <span class="fu">executor</span>(data[<span class="st">"faker"</span>][<span class="st">"name"</span>][<span class="st">"male_first_name"</span>])</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="fu">female_first_name</span>()<span class="op">::</span><span class="dt">String </span><span class="op">=</span> <span class="fu">executor</span>(data[<span class="st">"faker"</span>][<span class="st">"name"</span>][<span class="st">"female_first_name"</span>])</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">first_name</span>(genere<span class="op">::</span><span class="dt">String</span>=<span class="st">"None"</span>)<span class="op">::</span><span class="dt">String</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(<span class="fu">cmp</span>(genere, <span class="st">"M"</span>) <span class="op">==</span> <span class="fl">0</span>)</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="fu">male_first_name</span>()</span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elseif</span>(<span class="fu">cmp</span>(genere, <span class="st">"F"</span>) <span class="op">==</span> <span class="fl">0</span>)</span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="fu">female_first_name</span>()</span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a> <span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The <code>data</code> variable above is a dictionary holding all the data and patterns. When the package is first loaded, <code>data</code> is initialized as a global variable that is an empty dictionary of type <code>Dict{Any, Any}</code> and is then populated with the contents of the YAML files. It being a non-constant global variable may have something to do with the performance issues – one of the main rules of <a href="https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-untyped-global-variables">writing performant Julia</a> is <strong>don’t use non-constant untyped global variables</strong>.</p>
<p>In any case, calling</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>Faker.data[<span class="st">"faker"</span>][<span class="st">"name"</span>][<span class="st">"female_first_name"</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>simply returns a vector of names:</p>
<pre><code>4272-element Vector{String}:
 "Abbey"
 "Abbie"
 "Abby"
 "Abigail"
 "Ada"
 ⋮
 "Zoraida"
 "Zula"
 "Zulema"
 "Zulma"</code></pre>
<p>and all the <code>executor</code> function does is pick a name at random (though that’s not all it does, not for other types of data):</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>Faker.<span class="fu">executor</span>(Faker.data[<span class="st">"faker"</span>][<span class="st">"name"</span>][<span class="st">"female_first_name"</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>"Estela"</code></pre>
<p>Checking this function for type stability with <code>@code_warntype</code> shows that it’s not type stable, though again I’m not sure if that’s a problem here (it may be, but I’d have to do some more testing, which I haven’t had the time to do).</p>
<p>Anyhow, this gave me an idea and I decided to run some more benchmarks.</p>
</section>
<section id="the-revelation" class="level2">
<h2 class="anchored" data-anchor-id="the-revelation">The Revelation</h2>
<p>To isolate the impact of just <code>Faker.first_name()</code> being called a million times, I ran the following:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="pp">@btime</span> [Faker.<span class="fu">first_name</span>() for _ <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="fl">1_000_000</span>];</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>  75.036 s (58000002 allocations: 2.84 GiB)</code></pre>
<p>My idea was to see if sampling from a vector of names using Julia’s <code>rand</code> function was perhaps faster. To do that, I had to concat the male and female first name vectors and then sample that new vector:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">get_first_names</span>(n<span class="op">::</span><span class="dt">Int</span>)</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>    first_names_female <span class="op">=</span> Faker.data[<span class="st">"faker"</span>][<span class="st">"name"</span>][<span class="st">"female_first_name"</span>]</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>    first_names_male <span class="op">=</span> Faker.data[<span class="st">"faker"</span>][<span class="st">"name"</span>][<span class="st">"male_first_name"</span>]</span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>    first_names_all <span class="op">=</span> <span class="fu">vcat</span>(first_names_female, first_names_male)</span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="fu">rand</span>(first_names_all, n)</span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Benchmarking this function yielded quite the surprise:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="pp">@btime</span> first_name <span class="op">=</span> <span class="fu">get_first_names</span>(<span class="fl">1_000_000</span>);</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>  4.195 ms (5 allocations: 7.67 MiB)</code></pre>
<p>Wow.</p>
<p>Four milliseconds vs 75 seconds. That is an almost 18,000x speed-up! And notice the allocations and memory usage as well: 5 allocations vs 58 million, and ~8MiB vs 2.84GiB.</p>
<p>This was the magic sauce I had been looking for all along.</p>
</section>
<section id="julia-second-attempt" class="level2">
<h2 class="anchored" data-anchor-id="julia-second-attempt">Julia: Second Attempt</h2>
<p>I won’t go into many more details of the Faker.jl internals because a) I’m still getting to know the package, and b) I’m not sure they’re all that relevant or interesting for the purpose of this write-up (perhaps another blogpost).</p>
<p>I’d like to take a moment though to say that <strong>I sincerely hope this post does not come off as harsh or unduly critical of Faker.jl and its author</strong>. For one, I admire anyone who spends their free time writing open-source software, and in the case of Faker.jl, it fills a gap in the Julia ecosystem that, to my knowledge, no one else has stepped up to fill. Moreover, it has very nice documentation, albeit simple (and appropriately so). And last but far from least, <a href="https://github.com/neomatrixcode/Faker.jl/issues/30#issuecomment-1045495757">the author appears to be kind and friendly</a>, which counts for a lot in my book.</p>
<p>The next step was to write my own functions for each of the <code>Person</code> fields and benchmark them against the package-provided equivalents.</p>
<section id="id" class="level4">
<h4 class="anchored" data-anchor-id="id">id</h4>
<p>This is perhaps the simplest one, it’s just using <code>rand</code> to sample from a range. In the original Python version, there was no requirement to have the <code>id</code> field as a string (though if I was designing that database and using random integers, I would be sure to turn them into strings and left-pad with zeros).</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="fu">get_id</span>(n<span class="op">::</span><span class="dt">Int</span>) <span class="op">=</span> <span class="fu">rand</span>(<span class="fl">1000</span><span class="op">:</span><span class="fl">9999999999999</span>, n)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="last_name" class="level4">
<h4 class="anchored" data-anchor-id="last_name">last_name</h4>
<p>This one is almost the same as the <code>first_name</code> function, only we don’t have to concatenate two vectors together.</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">get_last_names</span>(n<span class="op">::</span><span class="dt">Int</span>)</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>    last_names <span class="op">=</span> Faker.data[<span class="st">"faker"</span>][<span class="st">"name"</span>][<span class="st">"last_name"</span>]</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="fu">rand</span>(last_names, n)</span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="email" class="level4">
<h4 class="anchored" data-anchor-id="email">email</h4>
<p>This one required a little bit more work. Instead of relying on the internal package mechanism to generate fake email addresses, I rolled my own.</p>
<p>In the first function, closures provide each of the possible email formats. A closure is randomly selected, and the function arguments, <code>first_name</code> and <code>last_name</code>, are used to generate a username.</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">determine_username_format</span>(first_name<span class="op">::</span><span class="dt">String</span>, last_name<span class="op">::</span><span class="dt">String</span>)</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># create closure for each type of format</span></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">_first_last</span>(first_name, last_name) <span class="op">=</span> first_name <span class="op">*</span> <span class="st">"."</span> <span class="op">*</span> last_name</span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">_last_first</span>(first_name, last_name) <span class="op">=</span> last_name <span class="op">*</span> <span class="st">"."</span> <span class="op">*</span> first_name</span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">_first_num</span>(first_name, last_name) <span class="op">=</span> first_name <span class="op">*</span> <span class="fu">string</span>(<span class="fu">rand</span>(<span class="fl">1</span><span class="op">:</span><span class="fl">99</span>))</span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a>    <span class="fu">_flast</span>(first_name, last_name) <span class="op">=</span> <span class="fu">first</span>(first_name, <span class="fl">1</span>) <span class="op">*</span> last_name</span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># randomly sample each format and return, not just function, but result from function</span></span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a>    formats <span class="op">=</span> (_first_last, _last_first, _first_num, _flast)</span>
<span id="cb38-9"><a href="#cb38-9" aria-hidden="true" tabindex="-1"></a>    <span class="fu">_email_format</span>(first_name, last_name) <span class="op">=</span> <span class="fu">rand</span>(formats)(first_name, last_name)</span>
<span id="cb38-10"><a href="#cb38-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="fu">_email_format</span>(first_name, last_name) <span class="op">|&gt;</span> lowercase</span>
<span id="cb38-11"><a href="#cb38-11" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Note that this function only works on scalar inputs and will be broadcast to vectors of first and last names later. Also, note how <code>_first_num</code> takes two arguments but only uses one – we need that to satisfy our mini <code>_email_format</code> API. If <code>_first_num</code> was defined with only the <code>first_name</code> argument, and that function was randomly selected for any given iteration, it would bomb. Thus we leave it with the same args as all the other inner functions. I know it feels hacky (and there is probably a name for this technique) but it simplifies the code.</p>
<p>Moving on, although there are more than three email domains (in the real world and in the Faker packages), I kept things simple and only used the main three that each account for ~17% of market share (according to my quick googling on the topic). I know this is cheating a little bit, but I honestly ran out of patience and figured this was good enough to get an idea of how fast this code can go.</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="fu">determine_email_domains</span>(n<span class="op">::</span><span class="dt">Int</span>) <span class="op">=</span> <span class="fu">rand</span>((<span class="st">"@gmail.com"</span>, <span class="st">"@yahoo.com"</span>, <span class="st">"@hotmail.com"</span>), n)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Finally, we take the vectors of names that are already generated and use them to call the two helper functions above (using the <code>.</code> notation to broadcast the <code>determine_username_format</code> function).</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">get_emails</span>(first_names<span class="op">::</span><span class="dt">Vector{String}</span>, last_names<span class="op">::</span><span class="dt">Vector{String}</span>)</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="fu">size</span>(first_names, <span class="fl">1</span>)</span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>    <span class="pp">@assert</span> n <span class="op">==</span> <span class="fu">size</span>(last_names, <span class="fl">1</span>) <span class="st">"first and last name vectors must be same size"</span></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>    formats <span class="op">=</span> <span class="fu">determine_username_format</span>.(first_names, last_names)</span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a>    domains <span class="op">=</span> <span class="fu">determine_email_domains</span>(n)</span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> formats <span class="op">.*</span> domains</span>
<span id="cb40-9"><a href="#cb40-9" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>You’ll notice that this is a deviation from the original post in that people’s names and their email addresses are now consistent since their names were used to generate their emails. This is an enhancement that is partly born out of convenience (we’re already generating first and last names, why spend more time generating more?) and partly because if we’re getting our hands dirty with hand-tuned optimization, we might as well make the dataset slightly more realistic. So we lose some (only three domains) and win some (email addresses based off the names).</p>
<p>I haven’t tested whether the closures are more helpful here, instead of regular functions, but I’m sort of keeping them as is mainly to keep the code somewhat organized. They also don’t need to start with an <code>_</code> but, again, helps me visually parse them a little easier.</p>
</section>
<section id="company" class="level4">
<h4 class="anchored" data-anchor-id="company">company</h4>
<p>Similar to the email functions above, I use closures to hold the pattern for the various company name formats, and then randomly select one of them to generate the pattern. Also, the <code>get_last_names</code> function gets re-used (yay).</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">get_companies</span>(n<span class="op">::</span><span class="dt">Int</span>)</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>    suffixes <span class="op">=</span> (<span class="st">" Inc"</span>, <span class="st">" and Sons"</span>, <span class="st">" and Daughters"</span>, <span class="st">", LLC"</span>, <span class="st">" Group"</span>)</span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">_last_suffix</span>(ln1, ln2, ln3) <span class="op">=</span> ln1 <span class="op">*</span> <span class="fu">rand</span>(suffixes)</span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">_last_last</span>(ln1, ln2, ln3) <span class="op">=</span> ln1 <span class="op">*</span> <span class="st">"-"</span> <span class="op">*</span> ln2</span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a>    <span class="fu">_last_x3</span>(ln1, ln2, ln3) <span class="op">=</span> ln1 <span class="op">*</span> <span class="st">", "</span> <span class="op">*</span> ln2 <span class="op">*</span> <span class="st">" and "</span> <span class="op">*</span> ln3</span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a>    formats <span class="op">=</span> (_last_suffix, _last_last, _last_x3)</span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true" tabindex="-1"></a>    last_names1 <span class="op">=</span> <span class="fu">get_last_names</span>(n)</span>
<span id="cb41-10"><a href="#cb41-10" aria-hidden="true" tabindex="-1"></a>    last_names2 <span class="op">=</span> <span class="fu">get_last_names</span>(n)</span>
<span id="cb41-11"><a href="#cb41-11" aria-hidden="true" tabindex="-1"></a>    last_names3 <span class="op">=</span> <span class="fu">get_last_names</span>(n)</span>
<span id="cb41-12"><a href="#cb41-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-13"><a href="#cb41-13" aria-hidden="true" tabindex="-1"></a>    <span class="fu">_company_name</span>(ln1, ln2, ln3) <span class="op">=</span> <span class="fu">rand</span>(formats)(ln1, ln2, ln3)</span>
<span id="cb41-14"><a href="#cb41-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-15"><a href="#cb41-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="fu">_company_name</span>.(last_names1, last_names2, last_names3)</span>
<span id="cb41-16"><a href="#cb41-16" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Once again, the inner functions don’t all use the given arguments, but we need that for the mini <code>_company_name</code> API.</p>
</section>
<section id="phone" class="level4">
<h4 class="anchored" data-anchor-id="phone">phone</h4>
<p>This one was kept pretty much as is from the package, and that’s fine because as we’ll see its performance is just fine as it is.</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">get_phone_numbers</span>(n<span class="op">::</span><span class="dt">Int</span>)</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> [Faker.<span class="fu">phone_number</span>() for _ <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span>n]</span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="save-all-the-people" class="level4">
<h4 class="anchored" data-anchor-id="save-all-the-people">Save All the People</h4>
<p>Putting it all together, we get this:</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">get_the_people</span>(n<span class="op">::</span><span class="dt">Int</span>)</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> <span class="fu">DataFrame</span>(</span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>        id <span class="op">=</span> <span class="fu">get_id</span>(n),</span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>        first_name <span class="op">=</span> <span class="fu">get_first_names</span>(n),</span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a>        last_name <span class="op">=</span> <span class="fu">get_last_names</span>(n),</span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a>        company<span class="op">=</span> <span class="fu">get_companies</span>(n),</span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a>        phone_number <span class="op">=</span> <span class="fu">get_phone_numbers</span>(n),</span>
<span id="cb43-8"><a href="#cb43-8" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb43-9"><a href="#cb43-9" aria-hidden="true" tabindex="-1"></a>    df.email <span class="op">=</span> <span class="fu">get_emails</span>(df.first_name, df.last_name)</span>
<span id="cb43-10"><a href="#cb43-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df</span>
<span id="cb43-11"><a href="#cb43-11" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>As you can see, we dispensed with the <code>Person</code> struct since we don’t really need it. Instead, we generate a <code>DataFrame</code> directly. And because we need our first and last names before we can generate our email addresses, the email field comes last.</p>
<p>Finally, we have actual data generation and saving to parquet files.</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">save_all_the_people</span>(num_people<span class="op">::</span><span class="dt">Int</span>, num_files<span class="op">::</span><span class="dt">Int</span>)</span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span>num_files</span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a>        file_num <span class="op">=</span> <span class="fu">string</span>(i, pad<span class="op">=</span><span class="fu">ndigits</span>(num_files))</span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a>        file_loc <span class="op">=</span> <span class="st">"./data/persons_</span><span class="sc">$</span>(file_num)<span class="st">.parquet"</span></span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a>        df <span class="op">=</span> <span class="fu">get_the_people</span>(num_people)</span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a>        <span class="fu">writefile</span>(file_loc, df; compression_codec<span class="op">=:</span>snappy)</span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb44-8"><a href="#cb44-8" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Now it’s time to benchmark again.</p>
</section>
</section>
<section id="the-final-benchmarks" class="level2">
<h2 class="anchored" data-anchor-id="the-final-benchmarks">The Final Benchmarks</h2>
<p>Before we benchmark the big one above, we’ll do some micro-benchmarking and test the functions that create each of the fields:</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="co">## benchmarks</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> N <span class="op">=</span> <span class="fl">1_000_000</span></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a><span class="co"># get_emails depends on other fields being generated first, </span></span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a><span class="co"># which needs to be done outside of benchmarking</span></span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a>first_names <span class="op">=</span> <span class="fu">get_first_names</span>(N)</span>
<span id="cb45-7"><a href="#cb45-7" aria-hidden="true" tabindex="-1"></a>last_names <span class="op">=</span> <span class="fu">get_last_names</span>(N)</span>
<span id="cb45-8"><a href="#cb45-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-9"><a href="#cb45-9" aria-hidden="true" tabindex="-1"></a><span class="pp">@btime</span> <span class="fu">get_id</span>(<span class="op">$</span>N);</span>
<span id="cb45-10"><a href="#cb45-10" aria-hidden="true" tabindex="-1"></a><span class="pp">@btime</span> <span class="fu">get_first_names</span>(<span class="op">$</span>N);</span>
<span id="cb45-11"><a href="#cb45-11" aria-hidden="true" tabindex="-1"></a><span class="pp">@btime</span> <span class="fu">get_last_names</span>(<span class="op">$</span>N);</span>
<span id="cb45-12"><a href="#cb45-12" aria-hidden="true" tabindex="-1"></a><span class="pp">@btime</span> <span class="fu">get_emails</span>(<span class="op">$</span>first_names, <span class="op">$</span>last_names);</span>
<span id="cb45-13"><a href="#cb45-13" aria-hidden="true" tabindex="-1"></a><span class="pp">@btime</span> <span class="fu">get_companies</span>(<span class="op">$</span>N);</span>
<span id="cb45-14"><a href="#cb45-14" aria-hidden="true" tabindex="-1"></a><span class="pp">@btime</span> <span class="fu">get_phone_numbers</span>(<span class="op">$</span>N);</span>
<span id="cb45-15"><a href="#cb45-15" aria-hidden="true" tabindex="-1"></a><span class="pp">@btime</span> <span class="fu">get_the_people</span>(<span class="op">$</span>N);</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>  3.186 ms (2 allocations: 7.63 MiB)
  4.270 ms (5 allocations: 7.67 MiB)
  4.134 ms (3 allocations: 7.63 MiB)
  309.268 ms (5747839 allocations: 262.10 MiB)
  80.762 ms (2331987 allocations: 128.40 MiB)
  367.853 ms (3000002 allocations: 187.66 MiB)
  812.161 ms (11082578 allocations: 645.02 MiB)</code></pre>
<p>Looks like we’ll be spending the most time generating emails and phone numbers. We’ll see if we can cut that down eventually.</p>
<p>Testing the big one:</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="pp">@btime</span> <span class="fu">save_all_the_people</span>(N, <span class="fl">10</span>);</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>  16.852 s (170856196 allocations: 10.43 GiB)</code></pre>
<p>Ok, not bad, generating 10 million people and saving to disk takes 17 seconds. But let’s see if we can do better. We’ll try multi-threading again, but this time just the <code>@threads</code> macro in front of the <code>for</code> loop should be good enough:</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">save_all_the_people_threaded</span>(num_people<span class="op">::</span><span class="dt">Int</span>, num_files<span class="op">::</span><span class="dt">Int</span>)</span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>    <span class="bu">Threads</span>.<span class="pp">@threads</span> <span class="cf">for</span> i <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span>num_files</span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a>        file_num <span class="op">=</span> <span class="fu">string</span>(i, pad<span class="op">=</span><span class="fu">ndigits</span>(num_files))</span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a>        file_loc <span class="op">=</span> <span class="st">"./data/persons_</span><span class="sc">$</span>(file_num)<span class="st">.parquet"</span></span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a>        df <span class="op">=</span> <span class="fu">get_the_people</span>(num_people)</span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true" tabindex="-1"></a>        <span class="fu">writefile</span>(file_loc, df; compression_codec<span class="op">=:</span>snappy)</span>
<span id="cb49-7"><a href="#cb49-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb49-8"><a href="#cb49-8" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We’ll go for 16 threads right out of the gate:</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="pp">@btime</span> <span class="fu">save_all_the_people_threaded</span>(N, <span class="fl">10</span>);</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>  4.709 s (170854140 allocations: 10.43 GiB)</code></pre>
<p>Not bad at all, though we’re only getting a 3x speed-up. Let’s try with 100 million:</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="pp">@btime</span> <span class="fu">save_all_the_people_threaded</span>(N, <span class="fl">100</span>);</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Here’s a screenshot of <code>htop</code> while this is happening btw: <img src="htop.png" class="img-fluid"></p>
<p>Benchmark result of 100 million people:</p>
<pre><code>  94.074 s (1708559591 allocations: 104.34 GiB)</code></pre>
<p>Ok interesting, looks like we can’t assume linear scaling after all! By that logic, 100 million should have taken about 50 seconds, but it actually took about twice that.</p>
<p>Not to belabor the point, <strong>doing an actual run with 1 billion people (1,000 parquet files) took about 23 minutes!</strong></p>
</section>
<section id="concluding-thoughts" class="level2">
<h2 class="anchored" data-anchor-id="concluding-thoughts">Concluding Thoughts</h2>
<p>Turns out we can indeed speed up the generation of fake data by quite a bit using plain Julia and a moderately powered laptop.</p>
<p>I might explore further optimization opportunities and do some proper profiling in future posts. For completeness, it would behoove me to play around with multi-processing, which I didn’t here since it’s more of a hassle and I doubt it would yield any appreciable performance improvement over the threaded version. I suspect there are significant gains to be made just hand-tuning the serial code, especially the string handling in the <code>get_emails</code> and <code>get_phone_numbers</code> functions.</p>
<p>I can imagine someone arguing, “but you probably spent more time researching this issue and writing custom code… surely $12 and 2 hours on an EC2 makes more sense for a one-time run like this.”</p>
<p>Absolutely. I definitely spent more than 2 hours looking into Faker.jl and coming up with my own solution. And if we were just trying to get a job done, that would be the way to go. But… where’s the fun in that?</p>
<p>This way, we learned a thing or two (or at least I did). And most importantly we are now armed with enough knowledge to make a PR or two to the Faker.jl repo and have the whole Julia and data communities benefit. If time allows, that is indeed what I’ll be looking to do.</p>
<p>Lastly, I also hope that any newbie Julia programmers or various data practioners (data enginners, data scientists, data analysits) will benefit from reading this post and learn a thing or two themselves.</p>
<p>Cheers and happy coding :)</p>
</section>
<section id="appendix-software-and-hardware" class="level2">
<h2 class="anchored" data-anchor-id="appendix-software-and-hardware">Appendix: Software and Hardware</h2>
<p>The code in this post was run with Julia 1.8.5 and the following package versions:</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="im">using</span> <span class="bu">Pkg</span></span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a><span class="bu">Pkg</span>.<span class="fu">status</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>Status `~/Dev/Julia/FakePeople/Project.toml`
  [a93c6f00] DataFrames v1.5.0
  [0efc519c] Faker v0.3.5
  [98572fba] Parquet2 v0.2.9
  [ac1d9e8a] ThreadsX v0.1.11</code></pre>
<p>with the following hardware/software specs:</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="fu">versioninfo</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>Julia Version 1.8.5
Commit 17cfb8e65ea (2023-01-08 06:45 UTC)
Platform Info:
  OS: Linux (x86_64-linux-gnu)
  CPU: 16 × AMD Ryzen 7 PRO 4750U with Radeon Graphics
  WORD_SIZE: 64
  LIBM: libopenlibm
  LLVM: libLLVM-13.0.1 (ORCJIT, znver2)
  Threads: 12 on 16 virtual cores
Environment:
  JULIA_NUM_THREADS = 12
  JULIA_EDITOR = code</code></pre>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>